Date. 2023/01/26


이터레이터(iterator) : 값을 차례대로 꺼낼 수 있는 객체(object)

for 반복문을 사용할 때 range를 예로 들면
for i in range(100):은 쉽게 설명하자면 0~99까지 연속된 숫자를 만들어낸다.
그러나 사실은 숫자를 모두 만들어 내는 것이 아니라 0부터 99까지 값을 차례대로 꺼낼 수 있는 이터레이터를 하나 만든다.
이후 반복할 때마다 이터레이터에서 숫자를 하나씩 꺼내서 반복하는 것임.

만약 연속된 숫자를 미리 만들면 숫자가 적을 때는 상관없지만 숫자가 아주 많을 때는 메모리를 많이 사용하게 되므로 성능에도 불리하다.
그래서 파이썬에서는 이터레이터만 생성하고 값이 필요한 시점이 되었을 때 값을 만드는 방식을 사용한다.
즉, 데이터 생성을 뒤로 미루는 것인데 이런 방식을 지연 평가(lazy evaluation)라고 한다.



반복 가능한 객체(iterable) : 문자열, 리스트, 딕셔너리, 세트
즉, 요소가 여러 개 들어있고, 한 번에 하나씩 꺼낼 수 있는 객체

객체가 반복 가능한 객체인지 알아보는 방법은 객체에 __iter__ 메서드가 들어있는지 확인해보면 됨.
• dir(객체) : 객체의 메서드를 리스트로 반환함.


__iter__를 호출해보면 이터레이터가 나옴.
>>> [1,2,3].__iter__()
<list_iterator object at 0x7fb3980e4b20>

이터레이터를 변수에 저장한 뒤 __next__ 메서드를 호출해보면 요소를 차례대로 꺼낼 수 있다.
>>> it = [1,2,3].__iter__()
>>> it.__next__()
1
__next__ 메서드를 통해 리스트에 있던 요소가 다 나오게 되면 
그다음에 또 __next__를 호출할때 StopIteration 예외가 발생함.
즉, 요소만큼 반복함. 

이처럼 이터레이터는 __next__로 요소를 계속 꺼내다가 꺼낼 요소가 없으면 
StopIteration 예외를 발생시켜서 반복을 끝냅니다.

[for와 반복 가능한 객체]
▶︎ for i in iterable:
1. iterable에서 __iter__로 이터레이터를 얻음.
2. 한 번 반복할 때마다 이터레이터에서 __next__로 숫자를 꺼내서 i에 저장
3. StopIteration이 발생하면 반복을 끝냄.

위의 예시에서는 반복 가능한 객체와 이터레이터가 분리되어 있지만 
클래스에 __iter__와 __next__ 메서드를 모두 구현하면 이터레이터를 만들 수 있습니다.
특히 __iter__, __next__를 가진 객체를 이터레이터 프로토콜(iterator protocol)을 지원한다고 함.


[참고 | 시퀀스 객체와 반복 가능한 객체의 차이]
반복 가능한 객체는 시퀀스 객체를 포함합니다.
리스트, 튜플, range, 문자열은 반복 가능한 객체이면서 시퀀스 객체입니다.
하지만, 딕셔너리와 세트는 반복 가능한 객체이지만 시퀀스 객체는 아닙니다.
왜냐하면 시퀀스 객체는 요소의 순서가 정해져 있고 연속적(sequence)으로 이어져 있어야 하는데, 
딕셔너리와 세트는 요소(키)의 순서가 정해져 있지 않기 때문!
즉, 시퀀스 객체가 반복 가능한 객체보다 좁은 개념입니다.
- 요소의 순서가 정해져 있고 연속적으로 이어져 있으면 시퀀스 객체
- 요소의 순서와는 상관없이 요소를 한 번에 하나씩 꺼낼 수 있으면 반복 가능한 객체



[이터레이터 만들기]
class 이터레이터이름:
    def __iter__(self):
        코드
 
    def __next__(self):
        코드

[이터레이터 언패킹]
이터레이터는 언패킹(unpacking)이 가능합니다.
물론 이터레이터가 반복하는 횟수와 변수의 개수는 같아야 합니다.
>>> one, two, three = range(1, 4)
>>> print(one, two, three)
1 2 3

사실 우리가 자주 사용하는 map도 이터레이터입니다. 
그래서 a, b, c = map(int, input().split())처럼 언패킹으로 변수 여러 개에 값을 할당할 수 있습니다.
>>> dir(map)
[~, __iter__, ~, __next__]


[참고 | 반환값을 _에 저장하는 이유]
함수를 호출한 뒤 반환값을 저장할 때 _(밑줄 문자)를 사용하는 경우가 있습니다.
반환값을 언패킹했을 때 _에 할당하는 것은 특정 순서의 반환값 사용하지 않고 무시하겠다는 관례적 표현입니다. 



[인덱스로 접근할 수 있는 이터레이터]
__getitem__ 메서드를 구현하면 인덱스로 접근할 수 있는 이터레이터를 만들 수 있음.

class 이터레이터이름:
    def __getitem__(self, 인덱스):
        코드

클래스에서 __getitem__만 구현해도 이터레이터가 되며 __iter__, __next__는 생략해도 됩니다(초깃값이 없다면 __init__도 생략 가능).



[iter, next 함수]
iter : 객체의 __iter__ 메서드를 호출함.
next : 객체의 __next__ 메서드를 호출함.


iter와 next는 이런 기능 이외에도 다양한 방식으로 사용 가능함.
[iter]
반복을 끝낼 값을 지정하면 특정 값이 나올 때 반복을 끝냅니다. 
이 경우에는 반복 가능한 객체 대신 호출 가능한 객체(callable)를 넣어줍니다.
참고로 반복을 끝낼 값은 sentinel이라고 부르는데 감시병이라는 뜻
• iter(호출가능한객체, 반복을끝낼값)

>>> import random
>>> it = iter(lambda : random.randint(0, 5), 2) # 이때 호출 가능한 객체를 넣어야 하므로 매개변수가 없는 함수 또는 람다 표현식으로 만들어줌.
>>> next(it)
0
>>> next(it)
3
>>> next(it)
1
>>> next(it)
Traceback (most recent call last):
  File "<pyshell#37>", line 1, in <module>
    next(it)
StopIteration

[next]
기본값을 지정할 수 있습니다. 기본값을 지정하면 반복이 끝나더라도 StopIteration이 발생하지 않고 기본값을 출력합니다.
즉, 반복할 수 있을 때는 해당 값을 출력하고, 반복이 끝났을 때는 기본값을 출력합니다. 
• next(반복가능한객체, 기본값)

>>> it = iter(range(3))
>>> next(it, 10)
0
>>> next(it, 10)
1
>>> next(it, 10)
2
>>> next(it, 10)
10
>>> next(it, 10)
10