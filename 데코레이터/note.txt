Date. 2023/02/03



코루틴 초기화를 자동화할 수 없나요?
코루틴 객체를 생성한 뒤 next를 호출하는 모양이 마음에 들지 않는다면 다음과 같이 코루틴 초기화 데코레이터를 만들어서 사용하면 됩니다. 
즉, 데코레이터 안에서 코루틴 객체를 만들고 next를 호출한 뒤 객체를 반환합니다.

이터레이터와 제너레이터의 차이는 무엇인가요?
제너레이터는 이터레이터를 반환하는 함수입니다.
따라서 모든 제너레이터 객체는 이터레이터입니다.
그러나, 이터레이터가 항상 제너레이터 객체인 것은 아닙니다.

코루틴의 이점은 무엇인가요?
보통 두 루틴이 동시에 실행되는 멀티태스킹은 하나의 변수에 값을 동시에 쓰면(write) 동기화 문제가 발생합니다.
따라서 크리티컬 섹션, 세마포어, 뮤텍스 등 동기화를 위한 락(lock)이 필요합니다.
하지만, 코루틴은 시분할 방식 멀티태스킹이라 동기화를 위한 락이 필요하지 않습니다. (동시에 접근하지 않는다는 말)



[데코레이터란?]
데코레이터는 장식하다, 꾸미다라는 뜻의 decorate에 er(or)을 붙인 말인데 장식하는 도구 정도로 설명할 수 있습니다.
클래스에서 메서드를 만들 때 @staticmethod, @classmethod, @abstractmethod 등을 붙였는데, 이렇게 @로 시작하는 것들이 데코레이터입니다.
즉, 함수(메서드)를 장식한다고 해서 이런 이름이 붙었습니다.
• 언제 사용할까?
▶︎▶︎ 데코레이터는 함수를 수정하지 않은 상태에서 추가 기능을 구현할 때 사용합니다.
• 함수를 어떻게 장식?
▶︎▶︎ 함수를 매개변수로 받고, 함수 안에서 함수를 만들고, 그 함수를 반환하는 클로저!


[@로 데코레이터 사용]
호출할 함수 위에 @데코레이터 형식으로 지정합니다.

@데코레이터
def 함수이름():
    코드


[참고 | 데코레이터를 여러 개 지정하기]
함수에는 데코레이터를 여러 개 지정할 수 있습니다.
이때 데코레이터가 실행되는 순서는 위에서 아래 순(이라고 하는데 아래서 위 순인듯.)

@데코레이터1
@데코레이터2
def 함수이름():
    코드


[매개변수와 반환값을 처리하는 데코레이터]
# decorator_param_return.py

[가변 인수 함수 데코레이터] # decorator_variable_argument.py
wrapper 함수를 가변 인수 함수로 만들면 됩니다.
위치 인수와 키워드 인수를 모두 받을 수 있도록 *args와 **kwargs를 지정해줍니다.(그래야 매개변수에 제한받지 않고 데코레이터로 장식할 수 있음.)


[참고 | 메서드에 데코레이터 사용하기]
클래스를 만들면서 메서드에 데코레이터를 사용할 때는 self를 주의해야 합니다. 
인스턴스 메서드는 항상 self를 받으므로 데코레이터를 만들 때도 wrapper 함수의 첫 번째 매개변수는 self로 지정해야 합니다(클래스 메서드는 cls). 
마찬가지로 func를 호출할 때도 self와 매개변수를 그대로 넣어야 합니다.


[매개변수가 있는 데코레이터]
이런 방식의 데코레이터는 값을 지정해서 동작을 바꿀 수 있습니다. 
매개변수가 있는 데코레이터를 만들 때는 함수를 하나 더 만들어야 합니다.
왜냐하면 가장 바깥의 함수가 매개변수를 받기 때문에 함수를 매개변수로 받는 함수가 필요하기 때문입니다.
사용할 때는 데코레이터에 ( )(괄호)를 붙인 뒤 인수를 넣어주면 됩니다.

@데코레이터(인수)
def 함수이름():
    코드


[참고 | 매개변수가 있는 데코레이터를 여러 개 지정하기]
@데코레이터1(인수)
@데코레이터2(인수)
def 함수이름():
    코드


[참고 | 원래 함수 이름이 안나온다면?]
데코레이터를 여러 개 사용하면 데코레이터에서 반환된 wrapper 함수가 다른 데코레이터로 들어갑니다.
따라서 함수의 __name__을 출력해보면 wrapper가 나옵니다.
함수의 원래 이름을 출력하고 싶다면 functools 모듈의 wraps 데코레이터를 사용해야 합니다.
@functools.wraps는 원래 함수의 정보를 유지시켜줍니다.
따라서 디버깅을 할 때 유용하므로 데코레이터를 만들 때는 @functools.wraps를 사용하는 것이 좋습니다.


[클래스로 데코레이터 만들기]
클래스를 활용할 때는 인스턴스를 함수처럼 호출하게 해주는 __call__ 메서드를 구현해야 합니다.
클래스로 데코레이터를 만들 때는 먼저 __init__ 메서드를 만들고 호출할 함수를 초깃값으로 받습니다. 
그리고 매개변수로 받은 함수를 속성으로 저장합니다. 이제 인스턴스를 호출할 수 있도록 __call__ 메서드를 만듭니다. 
데코레이터를 사용하는 방법은 클로저 형태의 데코레이터와 같습니다!
참고로 클래스로 만든 데코레이터는 @을 지정하지 않고, 데코레이터의 반환값을 호출하는 방식으로도 사용할 수 있습니다.


[클래스로 매개변수와 반환값을 처리하는 데코레이터]
클래스로 만든 데코레이터도 매개변수와 반환값을 처리할 수 있습니다.
클래스로 매개변수와 반환값을 처리하는 데코레이터를 만들 때는 __call__ 메서드에 매개변수를 지정하고, 
self.func에 매개변수를 넣어서 호출한 뒤에 반환값을 반환해주면 됩니다.


[클래스로 매개변수가 있는 데코레이터 만들기]
__init__ 메서드에서 데코레이터가 사용할 매개변수를 초깃값으로 받습니다. 
그리고 매개변수를 __call__ 메서드에서 사용할 수 있도록 속성에 저장합니다.
__call__ 메서드에서는 호출할 함수를 매개변수로 받습니다.
그리고 __call__ 메서드 안에서 wrapper 함수를 만들어줍니다.
데코레이터를 사용하는 방법은 클로저 형태의 데코레이터와 같습니다!


보통 데코레이터는 프로그램의 버그를 찾는 디버깅, 함수의 성능 측정, 함수 실행 전에 데이터 확인 등에 활용합니다!