Date: 2022/08/03

[리스트, 튜플, range, 문자열의 공통점]
이들 모두 값이 연속적(sequence)으로 이어져 있다는 점.

[시퀀스 자료형(sequence types)]
- 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형.(bytes, bytearray라는 자료형도 시퀀스 자료형.)
시퀀스 자료형의 가장 큰 특징은 공통된 동작과 기능을 제공한다는 점!

시퀀스 객체 : 시퀀스 자료형으로 만든 객체 # 시퀀스 객체에 들어있는 각 값을 요소(element)

[시퀀스 객체 안에 특정 값이 있는지 확인하는 방법]
시퀀스 객체에 in 연산자를 사용했을 때 특정 값이 있으면 True, 없으면 False.
>>> a = (1,2,3) # 시퀀스 객체
>>> 3 in a
True
>>> 4 in a
False
반대로 in 앞에 not을 붙이면 특정 값이 없는지 확인함.
>>> 4 not in a
True

[시퀀스 객체 연결]
시퀀스 객체는 + 연산자를 사용하여 객체를 서로 연결하여 새 객체를 만들 수 있다. 
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> a+b
[1, 2, 3, 4, 5, 6]
(단, range는 + 연산자로 객체를 연결할 수 없다.) # range를 list or tuple로 형변환 후 연결하면 됨.

[시퀀스 객체 반복]
시퀀스객체 * 정수 (0 또는 음수를 곱하면 빈 객체가 나오며 실수는 곱할 수 없다.)
>>> ['a', 'b', 'c'] * 2
['a', 'b', 'c', 'a', 'b', 'c']
(단, range는 * 연산자를 사용하여 반복할 수 없다.) # range를 list or tuple로 형변환 후 반복하면 됨.

[시퀀스 객체의 요소 개수]
len 함수를 사용. # len(시퀀스객체)
>>> a = [1,2,3,4,5]
>>> len(a)
5

[UTF-8 문자열의 바이트 수 구하기]
>>> hello = '안녕하세요' # UTF-8에서 한글 글자 하나는 3바이트로 표현
>>> len(hello.encode('utf-8')) # 문자열을 utf-8로 인코딩 후 len()
15
>>> hello.encode('utf-8')
b'\xec\x95\x88\xeb\x85\x95\xed\x95\x98\xec\x84\xb8\xec\x9a\x94'
* 참고) 파이썬 3에서 len은 문자의 개수를 구해주지만 파이썬 2.7에서는 실제 바이트 수를 구해주는 차이점이 있다.

[시퀀스 객체에 들어있는 요소에 접근하는 방법]
- 시퀀스객체[인덱스]
>>> a = [1,2,3]
>>> a[0]
1
>>> r = range(0,5)
>>> r[4]
4

인덱스 : 시퀀스 객체의 각 요소의 순서 (시퀀스 객체의 인덱스는 항상 0부터 시작함.), 인덱스를 음수로 지정하면 뒤에서부터 요소에 접근함.

* 참고) 시퀀스 객체에서 [ ](대괄호)를 사용하면 실제로는 __getitem__ 메서드를 호출하여 요소를 가져온다.
따라서 직접 __getitem__메서드를 호출하여 요소를 가져올 수도 있다.
>>> a = [1,2,3]
>>> a.__getitem__(1)
2

인덱스의 범위를 벗어나면?
IndexError: (sequence tpyes) index out of range 

[시퀀스 객체의 요소에 값을 할당하는 방법]
시퀀스 객체는 [ ]로 요소에 접근한 뒤 =로 값을 할당함. 
- 시퀀스객체[인덱스] = 값 (범위를 벗어난 인덱스는 지정할 수는 없다.)
튜플, range, 문자열은 안에 저장된 요소를 변경할 수 없다! (즉, 시퀀스 자료형 중에서 튜플, range, 문자열은 읽기 전용)
>>> a = [0, 0, 0]
>>> a[0] = 1
>>> a[1] = 2
>>> a[2] = 3
>>> a
[1, 2, 3]

[del로 시퀀스 객체의 요소 삭제]
- del 시퀀스객체[인덱스]
>>> a = [1,2,3]
>>> del a[1]
>>> a
[1, 3]
튜플, range, 문자열은 안에 저장된 요소를 삭제할 수 없다!

[시퀀스 객체를 일부 추출하는 법]
- 시퀀스객체[시작인덱스:끝인덱스] # 끝 인덱스는 가져오려는 범위에 포함되지 않음.
(실제로 가져오는 요소는 시작 인덱스부터 끝 인덱스 - 1까지)
>>> a = [1,2,3,4,5]
>>> a[0:3]
[1, 2, 3]
- [인덱스 증가폭 사용]
    - 시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭]
    >>> a = [1,2,3,4,5,6,7,8,9,10]
    >>> a[0:-1:2]
    [1, 3, 5, 7, 9]
    >>> a[4::-1]
    [5, 4, 3, 2, 1]
- [인덱스 생략]
    - 시퀀스객체[:끝인덱스] # 처음부터 끝인덱스-1 까지
    - 시퀀스객체[시작인덱스:] # 시작인덱스부터 끝까지
    - 시퀀스객체[:] == 시퀀스객체[::] # 전체
    인덱스증가폭에서도 생략하여 사용가능.
    >>> a = [1,2,3,4,5,6,7,8,9,10]
    >>> a[:-1]
    [1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> a[3:]
    [4, 5, 6, 7, 8, 9, 10]
    >>> a[1::2]
    [2, 4, 6, 8, 10]

range에 슬라이스를 사용하면 지정된 범위의 숫자를 생성하는 range 객체를 새로 만든다!
- range객체[시작인덱스:끝인덱스]
- range객체[시작인덱스:끝인덱스:인덱스증가폭]
>>> r = range(10)
>>> r
range(0, 10)
>>> r[4:7]
range(4, 7)
>>> r[4:]
range(4, 10)
>>> r[:7:2]
range(0, 7, 2)

* 참고) slice 객체 사용하여 슬라이싱 가능.
슬라이스객체 = slice(끝인덱스) # slice(시작인덱스, 끝인덱스), slice(시작인덱스, 끝인덱스, 인덱스증가폭)
시퀀스객체[슬라이스객체]
시퀀스객체.__getitem__(슬라이스객체)
>>> s = slice(0,7)
>>> a = [0,1,2,3,4,5,6,7,8,9]
>>> a[s]
[0, 1, 2, 3, 4, 5, 6]

[슬라이스에 요소 할당]
시퀀스 객체는 슬라이스로 범위를 지정하여 여러 요소에 값을 할당할 수 있다. (단, range,tuple,str은 불가능.)
- 시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체
슬라이스 범위와 할당할 리스트의 요소 개수를 맞추지 않아도 상관없다. (요소 개수를 맞추지 않아도 알아서 할당됨.)
>>> a = [0,1,2,3,4,5,6,7,8,9]
>>> a[:3] = ['a','b','c']
>>> a
['a', 'b', 'c', 3, 4, 5, 6, 7, 8, 9]
- 시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭] = 시퀀스객체
인덱스 증가폭을 지정했을 때는 슬라이스 범위의 요소 개수와 할당할 요소 개수가 정확히 일치해야함.
>>> a = [0,1,2,3,4,5,6,7,8,9]
>>> a[::2] = ['A', 'B', 'C', 'D', 'E']
>>> a
['A', 1, 'B', 3, 'C', 5, 'D', 7, 'E', 9]

[del로 시퀀스 객체의 슬라이스 삭제]
- del 시퀀스객체[슬라이싱]
>>> a = [0,1,2,3,4,5,6,7,8,9]
>>> del a[::2]
>>> a
[1, 3, 5, 7, 9]