Date. 2023/02/05


[정규표현식(regular expression)]
일정한 규칙(패턴)을 가진 문자열을 표현하는 방법
복잡한 문자열 속에서 특정한 규칙으로 된 문자열을 검색한 뒤 추출하거나 바꿀 때 사용
또는, 문자열이 정해진 규칙에 맞는지 판단할 때도 사용
정규표현식은 re 모듈을 가져와서 사용

[문자열 판단하기]
match 함수에 정규표현식 패턴과 판단할 문자열을 넣습니다.
문자열에 특정 문자열이 포함되어 있는지 판단합니다.
• re.match('패턴', '문자열')

>>> import re
>>> re.match('Hello', 'Hello, world!')
<re.Match object; span=(0, 5), match='Hello'>
>>> re.match('world', 'Hello, world!')
>>> re.match('world!', 'Hello, world!')

문자열이 있으면 매치(SRE_Match) 객체가 반환되고 없으면 아무것도 반환되지 않습니다.
사실 문자열 메서드 find()를 사용해도 충분히 가능하다. 이제부터 문자열 메서드로 할 수 없는 것들을 알아보자.




[문자열이 맨 앞에 오는지 맨 뒤에 오는지]
정규표현식은 특정 문자열이 맨 앞에 오는지 맨 뒤에 오는지 판단할 수 있습니다.
- 문자열 앞에 ^를 붙이면 문자열이 맨 앞에 오는지 판단
▶︎▶︎ ^문자열
- 문자열 뒤에 $를 붙이면 문자열이 맨 뒤에 오는지 판단(특정 문자열로 끝나는지)
▶︎▶︎ 문자열$

>>> import re
>>> re.search('^Hello', 'Hello, world!')
<re.Match object; span=(0, 5), match='Hello'>
>>> re.search('world$', 'Hello, world!')
>>> re.search('world!$', 'Hello, world!')
<re.Match object; span=(7, 13), match='world!'>

단, 이때는 match 대신 search 함수를 사용해야 합니다!
match 함수는 문자열 처음부터 매칭되는지 판단하지만, search는 문자열 일부분이 매칭되는지 판단합니다.


[지정된 문자열이 하나라도 포함되는지]
- |는 특정 문자열에서 지정된 문자열(문자)이 하나라도 포함되는지 판단
기본 개념은 OR 연산자와 같습니다.
▶︎▶︎ 문자열|문자열
>>> re.match('hello|world', 'hello')
<re.Match object; span=(0, 5), match='hello'>


[문자열이 숫자로 되어있는지]
[ ](대괄호) 안에 숫자 범위를 넣으며 * 또는 +를 붙입니다.
*는 문자(숫자)가 0개 이상 있는지, +는 1개 이상 있는지 판단
▶︎▶︎ [0-9]*
▶︎▶︎ [0-9]+
>>> re.match('[0-9]*', '1234')
<re.Match object; span=(0, 4), match='1234'>
>>> re.match('[0-9]*', 'abcd')
<re.Match object; span=(0, 0), match=''>
>>> re.match('[0-9]+', 'abcd')

그럼 *와 +는 어디에 활용할까요? a*b와 a+b를 확인해보면 쉽게 알 수 있습니다.
>>> re.match('a*b', 'b')      # b에는 a가 0개 이상 있으므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 1), match='b'>
>>> re.match('a+b', 'b')      # b에는 a가 1개 이상 없으므로 패턴에 매칭되지 않음
>>> re.match('a*b', 'aab')    # aab에는 a가 0개 이상 있으므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 3), match='aab'>
>>> re.match('a+b', 'aab')    # aab에는 a가 1개 이상 있으므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 3), match='aab'>
a*b, a+b에서 b는 무조건 있어야 하는 문자이다.


[문자가 한 개만 있는지]
- ?는 ? 앞의 문자(범위)가 0개 또는 1개인지 판단
- .은 .이 있는 위치에 아무 문자(숫자)가 1개 있는지 판단
▶︎▶︎ 문자?
▶︎▶︎ [0-9]?
▶︎▶︎ .
>>> re.match('abc?d', 'abd')         # abd에서 c 위치에 c가 0개 있으므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 3), match='abd'>
>>> re.match('ab[0-9]?c', 'ab3c')    # [0-9] 위치에 숫자가 1개 있으므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 4), match='ab3c'>
>>> re.match('ab.d', 'abxd')         # .이 있는 위치에 문자가 1개 있으므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 4), match='abxd'>


[문자 개수 판단]
문자 뒤에 {개수} 형식을 지정, 문자열의 경우에는 문자열을 괄호로 묶고 뒤에 {개수} 형식을 지정
특정 범위의 문자(숫자)가 몇 개 있는지 판단할 수도 있습니다. 이때는 범위 [ ] 뒤에 {개수} 형식을 지정
문자(숫자)의 개수 범위도 지정할 수 있습니다. {시작개수,끝개수} 형식으로 시작 개수와 끝 개수를 지정해주면 특정 개수 사이에 들어가는지 판단
▶︎▶︎ 문자{개수}
▶︎▶︎ (문자열){개수}

>>> re.match('h{3}', 'hhhello')
<re.Match object; span=(0, 3), match='hhh'>
>>> re.match('(hello){2}', 'hellohello')
<re.Match object; span=(0, 10), match='hellohello'>

▶︎▶︎ [0-9]{개수}

>>> re.match('[0-9]{3}-[0-9]{4}-[0-9]{4}', '010-8494-3277')
<re.Match object; span=(0, 13), match='010-8494-3277'>
>>> re.match('[0-9]{3}-[0-9]{4}-[0-9]{4}', '010-8494-327') # 숫자 3개-4개-4개 패턴에 매칭되지 않음

▶︎▶︎ (문자){시작개수,끝개수}
▶︎▶︎ (문자열){시작개수,끝개수}
▶︎▶︎ [0-9]{시작개수,끝개수}

>>> re.match('[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}', '02-844-3277')
<re.Match object; span=(0, 11), match='02-844-3277'>
>>> re.match('[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}', '02-84-3277')# 2~3개-3~4개-4개 패턴에 매칭되지 않음


[숫자와 영문 문자를 조합해서 판단]
영문 문자 범위는 a-z, A-Z와 같이 표현합니다.
▶︎▶︎ a-z
▶︎▶︎ A-Z
>>> re.match('[a-zA-Z0-9]+', 'Hello1234')    # a부터 z, A부터 Z, 0부터 9까지 1개 이상 있으므로
<_sre.SRE_Match object; span=(0, 9), match='Hello1234'>                        # 패턴에 매칭됨
>>> re.match('[A-Z0-9]+', 'hello')    # 대문자, 숫자는 없고 소문자만 있으므로 패턴에 매칭되지 않음

이처럼 숫자, 영문 문자 범위는 a-zA-Z0-9 또는 A-Z0-9와 같이 붙여 쓰면 됩니다.
한글은 어떻게 사용할까요? 영문 문자와 방법이 같습니다. 가-힣처럼 나올 수 있는 한글 조합을 정해주면 됩니다.
▶︎▶︎ 가-힣
>>> re.match('[가-힣]+', '홍길동')
<re.Match object; span=(0, 3), match='홍길동'>


[특정 문자 범위에 포함되지 않는지 판단]
문자(숫자) 범위 앞에 ^를 붙이면 해당 범위를 제외
▶︎▶︎ [^범위]*
▶︎▶︎ [^범위]+
>>> re.match('[^A-Z]+', 'Hello') # 대문자를 제외. 대문자가 있으므로 패턴에 매칭되지 않음
>>> re.match('[^A-Z]+', 'hello')
<re.Match object; span=(0, 5), match='hello'>

특정 문자열로 시작하는지 판단할 때도 ^를 사용했었는데 문법이 비슷해서 이 부분은 헷갈리기 쉽습니다. 
범위를 제외할 때는 '[^A-Z]+'와 같이 [ ] 안에 넣어주고, 특정 문자 범위로 시작할 때는 '^[A-Z]+'와 같이 [ ] 앞에 붙여줍니다.
▶︎▶︎ ^[범위]*
▶︎▶︎ ^[범위]+
>>> re.search('^[A-Z]+', 'Hello') # 대문자로 시작하므로 매칭됨
<re.Match object; span=(0, 1), match='H'>

특정 문자(숫자) 범위로 끝나는지 확인할 때는 정규표현식 뒤에 $를 붙이면 됩니다.
▶︎▶︎ [범위]*$
▶︎▶︎ [범위]+$
>>> re.search('[A-Z]+$', 'Hello1234')
>>> re.search('[0-9]+$', 'Hello1234')
<re.Match object; span=(5, 9), match='1234'>


[특수 문자 판단]
특수 문자를 판단할 때는 특수 문자 앞에 \를 붙이면 됩니다. 
단, [ ] 안에서는 \를 붙이지 않아도 되지만 에러가 발생하는 경우에는 \를 붙입니다.
▶︎▶︎ \특수문자
>>> re.search('\*+', '1 ** 2')
<re.Match object; span=(2, 4), match='**'>
>>> re.match('[$()a-zA-Z0-9]+', '$(document)')    # $, (, )와 문자, 숫자가 들어있는지 판단
<_sre.SRE_Match object; span=(0, 11), match='$(document)'>

단순히 숫자인지 문자인지 판단할 때는 \d, \D, \w, \W를 사용하면 편리합니다.
▶︎▶︎ \d: [0-9]와 같음. 모든 숫자
▶︎▶︎ \D: [^0-9]와 같음. 숫자를 제외한 모든 문자
▶︎▶︎ \w: [a-zA-Z0-9_]와 같음. 영문 대소문자, 숫자, 밑줄 문자
▶︎▶︎ \W: [^a-zA-Z0-9_]와 같음. 영문 대소문자, 숫자, 밑줄 문자를 제외한 모든 문자

>>> re.match('\d+', '1234')          # 모든 숫자이므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 4), match='1234'>
>>> re.match('\D+', 'Hello')         # 숫자를 제외한 모든 문자이므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 5), match='Hello'>
>>> re.match('\w+', 'Hello_1234')    # 영문 대소문자, 숫자, 밑줄 문자이므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 10), match='Hello_1234'>
>>> re.match('\W+', '(:)')    # 영문 대소문자, 숫자, 밑줄문자를 제외한 모든 문자이므로 패턴에 매칭됨
<_sre.SRE_Match object; span=(0, 3), match='(:)'>


[공백 처리]
공백은 ' '처럼 공백 문자를 넣어도 되고, \s 또는 \S로 표현할 수도 있습니다.
▶︎▶︎ \s: [ \t\n\r\f\v]와 같음. 공백(스페이스), \t(탭) \n(새 줄, 라인 피드), \r(캐리지 리턴), \f(폼피드), \v(수직 탭)을 포함
▶︎▶︎ \S: [^ \t\n\r\f\v]와 같음. 공백을 제외하고 \t, \n, \r, \f, \v만 포함

>>> re.match('[a-zA-Z0-9 ]+', 'Hello 1234')     # ' '로 공백 표현
<_sre.SRE_Match object; span=(0, 10), match='Hello 1234'>
>>> re.match('[a-zA-Z0-9 ]+', ' ')
<re.Match object; span=(0, 1), match=' '>
>>> re.match('[a-zA-Z0-9\s]+', 'Hello 1234')    # \s로 공백 표현
<_sre.SRE_Match object; span=(0, 10), match='Hello 1234'>


[참고 | 같은 정규표현식 패턴을 자주 사용할 때]
매번 match나 search 함수에 정규표현식 패턴을 지정하는 방법은 비효율적
같은 패턴을 자주 사용할 때는 compile 함수를 사용하여 정규표현식 패턴을 객체로 만든 뒤 match 또는 search 메서드를 호출하자.

객체 = re.compile('패턴')
객체.match('문자열')
객체.search('문자열')

>>> p = re.compile('[0-9]+')
>>> p.match('1234')
<re.Match object; span=(0, 4), match='1234'>
>>> p.search('abcd')


[정규표현식을 그룹으로 묶는 방법]
정규표현식 그룹은 해당 그룹과 일치하는 문자열을 얻어올 때 사용합니다.
패턴 안에서 정규표현식을 ( )(괄호)로 묶으면 그룹이 됩니다.
▶︎▶︎ (정규표현식) (정규표현식)
>>> m = re.match('([0-9]+) ([0-9]+)', '10 295') # 공백으로 구분된 숫자를 두 그룹으로 나누어서 찾음.
>>> m.group(1)
'10'
>>> m.group(2)
'295'
>>> m.group(0)
'10 295'

매치 객체의 group 메서드에 숫자를 지정하면 해당 그룹에 매칭된 문자열을 반환홤.
그리고 groups 메서드는 각 그룹에 해당하는 문자열을 튜플로 반환홤.
▶︎▶︎ 매치객체.groups()
>>> m.groups()
('10', '295')

그룹 개수가 많아지면 숫자로 그룹을 구분하기가 힘들어집니다. 
이때는 그룹에 이름을 지으면 편리합니다. 그룹의 이름은 ( )(괄호) 안에 ?P<이름> 형식으로 지정합니다.
▶︎▶︎ (?P<이름>정규표현식)
>>> m = re.match('(?P<func>[a-zA-Z_][a-zA-Z0-9_]+)\((?P<arg>\w+)\)', 'print(1234)')
>>> m.group('func')    # 그룹 이름으로 매칭된 문자열 출력
'print'
>>> m.group('arg')     # 그룹 이름으로 매칭된 문자열 출력
'1234'


[패턴에 매칭되는 모든 문자열 가져오기]
그룹 지정 없이 패턴에 매칭되는 모든 문자열을 가져오려면 어떻게 해야 할까요?
이때는 findall 함수를 사용하며 매칭된 문자열을 리스트로 반환합니다.
▶︎▶︎ re.findall('패턴', '문자열')
>>> re.findall('[a-z]+', 'aa a bb b cc c')
['aa', 'a', 'bb', 'b', 'cc', 'c']


[참고 | *, +와 그룹 활용]
정규표현식에서 +과 *을 조합하여 사용할 때는 그룹으로 묶어서 사용
예를 들어 (.[a-z]+)*는 점과 영문 소문자가 1개 이상 있는지 판단하고, 이것 자체가 0개 이상인지 판단합니다. 
즉, 규칙은 반드시 지켜야 하지만 있어도 되고 없어도 되는 상황에 사용합니다.


[문자열 바꾸기]
문자열을 바꿀 때는 sub 함수를 사용하며 패턴, 바꿀 문자열, 문자열, 바꿀 횟수를 넣어줍니다. 
여기서 바꿀 횟수를 넣으면 지정된 횟수만큼 바꾸며 바꿀 횟수를 생략하면 찾은 문자열을 모두 바꿉니다.
▶︎▶︎ re.sub('패턴', '바꿀문자열', '문자열', 바꿀횟수)
>>> re.sub('fuck|shit', '****', 'fuck you! little shit!')
'**** you! little ****!'

sub 함수는 바꿀 문자열 대신 교체 함수를 지정할 수도 있습니다. 
교체 함수는 매개변수로 매치 객체를 받으며 바꿀 결과를 문자열로 반환하면 됩니다. 
>>> re.sub('[0-9]+', lambda m: str(int(m.group()) * 10), '1 2 Fizz 4 Buzz Fizz 7 8')
'10 20 Fizz 40 Buzz Fizz 70 80'


[찾은 문자열을 결과에 다시 사용]
먼저 정규표현식을 그룹으로 묶습니다. 그러고 나면 바꿀 문자열에서 \\숫자 형식으로 매칭된 문자열을 가져와서 사용할 수 있습니다.
▶︎▶︎ \\숫자
>>> re.sub('([a-z]+) ([0-9]+)', '\\2 \\1 \\2 \\1', 'hello 1234')    # 그룹 2, 1, 2, 1 순으로 바꿈
'1234 hello 1234 hello'
>>> re.sub('({\s*)"(\w+)":\s*"(\w+)"(\s*})', '<\\2>\\3</\\2>', '{ "name": "james" }')
'<name>james</name>'

만약 그룹에 이름을 지었다면 \\g<이름> 형식으로 매칭된 문자열을 가져올 수 있습니다
▶︎▶︎ \\g<이름>
▶︎▶︎ \\g<숫자>
>>> re.sub('({\s*)"(?P<key>\w+)":\s*"(?P<value>\w+)"(\s*})', '<\\g<key>>\\g<value></\\g<key>>', '{ "name": "james" }')
'<name>james</name>'


[참고 | raw 문자열 사용]
정규표현식의 특수 문자를 판단하려면 \를 붙여야 합니다. 
여기서 문자열 앞에 r을 붙여주면 원시(raw) 문자열이 되어 \를 붙이지 않아도 특수 문자를 그대로 판단할 수 있습니다.
따라서 raw 문자열에서는 \\숫자, \\g<이름>, \\g<숫자>는 \숫자, \g<이름>, \g<숫자> 형식처럼 \를 하나만 붙여서 사용할 수 있습니다.
- r'\숫자 \g<이름> \g<숫자>'